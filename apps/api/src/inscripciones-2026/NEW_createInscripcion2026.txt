/**
 * Crea una nueva inscripci√≥n 2026 con transacci√≥n at√≥mica completa
 *
 * Flujo:
 * 1. Validaciones (sin DB)
 * 2. C√°lculos (sin DB)
 * 3. MercadoPago.createPreference() ‚Üê PRIMERO (fail-fast)
 * 4. $transaction con timeout y isolation level
 * 5. Retornar respuesta
 */
async createInscripcion2026(
  dto: CreateInscripcion2026Dto,
): Promise<CreateInscripcion2026Response> {
  // 1Ô∏è‚É£ Validaciones (sin DB)
  this.validateInscriptionData(dto);

  // 2Ô∏è‚É£ C√°lculos (sin DB)
  const inscripcionFee = this.calculateInscriptionFee(dto.tipo_inscripcion);
  const cursosPerStudent = dto.estudiantes.map(
    (e) => e.cursos_seleccionados?.length || 0
  );
  const { total: monthlyTotal, descuento: siblingDiscount } =
    this.calculateMonthlyTotal(
      dto.tipo_inscripcion,
      dto.estudiantes.length,
      cursosPerStudent,
    );

  // 3Ô∏è‚É£ üî• CR√çTICO: Crear preferencia MercadoPago PRIMERO (fail-fast)
  const backendUrl = this.configService.get<string>('BACKEND_URL') || 'http://localhost:3001';
  const frontendUrl = this.configService.get<string>('FRONTEND_URL') || 'http://localhost:3000';

  let mercadopagoPreferenceId = '';
  let mercadopagoInitPoint = '';

  // Verificar si MercadoPago est√° en modo mock
  if (this.mercadoPagoService.isMockMode()) {
    this.logger.warn('MercadoPago en modo MOCK - Generando preferencia placeholder');
    // En modo mock, generamos IDs temporales que se actualizar√°n en la transacci√≥n
    mercadopagoPreferenceId = 'MP-MOCK-TEMP';
    mercadopagoInitPoint = `${frontendUrl}/inscripcion-2026/mock-checkout`;
  } else {
    // Generar preferencia real con MercadoPago ANTES de transacci√≥n
    // Usamos datos temporales del tutor del DTO (no existe en DB todav√≠a)
    const preferenceData = this.mercadoPagoService.buildInscripcion2026PreferenceData(
      dto.tipo_inscripcion,
      inscripcionFee,
      {
        email: dto.tutor.email,
        nombre: dto.tutor.nombre,
        apellido: dto.tutor.apellido || undefined,
      },
      'TEMP_INSCRIPCION_ID', // Se actualizar√° despu√©s
      'TEMP_TUTOR_ID', // Se actualizar√° despu√©s
      dto.estudiantes.length,
      backendUrl,
      frontendUrl,
    );

    try {
      const preference = await this.mercadoPagoService.createPreference(preferenceData);
      mercadopagoPreferenceId = preference.id || '';
      mercadopagoInitPoint = preference.init_point || '';

      this.logger.log('MercadoPago preference created successfully', {
        preferenceId: mercadopagoPreferenceId,
        initPoint: mercadopagoInitPoint,
        amount: inscripcionFee,
      });
    } catch (error) {
      this.logger.error('Failed to create MercadoPago preference', {
        error: error.message,
        stack: error.stack,
        dto: {
          tipo: dto.tipo_inscripcion,
          numEstudiantes: dto.estudiantes.length,
        },
      });
      throw new BadRequestException(
        'No se pudo crear la preferencia de pago. Intente nuevamente.'
      );
    }
  }

  // 4Ô∏è‚É£ üî• TODO lo dem√°s en transacci√≥n at√≥mica
  const startTime = Date.now();
  let result;

  try {
    result = await this.prisma.$transaction(async (tx) => {
      // 4.1. Buscar o crear tutor
      let tutor = await tx.tutor.findUnique({
        where: { email: dto.tutor.email },
      });

      if (!tutor) {
        const hashedPassword = await bcrypt.hash(dto.tutor.password, 10);
        tutor = await tx.tutor.create({
          data: {
            nombre: dto.tutor.nombre,
            apellido: dto.tutor.apellido || '',
            email: dto.tutor.email,
            telefono: dto.tutor.telefono,
            dni: dto.tutor.dni,
            cuil: dto.tutor.cuil,
            password_hash: hashedPassword,
            debe_cambiar_password: false,
            debe_completar_perfil: false,
            ha_completado_onboarding: true,
            roles: DEFAULT_ROLES.TUTOR,
          },
        });
      }

      // 4.2. Crear inscripci√≥n
      const inscripcion = await tx.inscripcion2026.create({
        data: {
          tutor_id: tutor.id,
          tipo_inscripcion: dto.tipo_inscripcion,
          estado: 'pending',
          inscripcion_pagada: inscripcionFee,
          descuento_aplicado: siblingDiscount,
          total_mensual_actual: monthlyTotal,
          origen_inscripcion: dto.origen_inscripcion,
          ciudad: dto.ciudad,
        },
      });

      // 4.3. Crear estudiantes con PINs y sus inscripciones
      const estudiantesCreados = [];

      for (const estudianteDto of dto.estudiantes) {
        // Generar PIN √∫nico
        const pin = await this.generateUniquePin();

        // Generar username
        const username = this.generateUsername(estudianteDto.nombre);

        // Crear estudiante en tabla principal
        const estudiante = await tx.estudiante.create({
          data: {
            tutor_id: tutor.id,
            nombre: estudianteDto.nombre,
            apellido: '',
            edad: estudianteDto.edad,
            nivelEscolar: 'Primaria',
            username,
            password_hash: await bcrypt.hash(pin, 10),
            debe_cambiar_password: true,
            roles: DEFAULT_ROLES.ESTUDIANTE,
          },
        });

        // Crear registro de inscripci√≥n de estudiante
        const estudianteInscripcion = await tx.estudianteInscripcion2026.create({
          data: {
            inscripcion_id: inscripcion.id,
            estudiante_id: estudiante.id,
            nombre: estudianteDto.nombre,
            edad: estudianteDto.edad,
            dni: estudianteDto.dni,
            pin,
          },
        });

        estudiantesCreados.push({
          estudiante,
          estudianteInscripcion,
          pin,
          cursosSeleccionados: estudianteDto.cursos_seleccionados || [],
          mundoSeleccionado: estudianteDto.mundo_seleccionado,
        });
      }

      // 4.4. Crear cursos seleccionados (usando create individual con Promise.all)
      const cursosPromises = [];
      estudiantesCreados.forEach(({ estudianteInscripcion, cursosSeleccionados }) => {
        if (cursosSeleccionados && cursosSeleccionados.length > 0) {
          cursosSeleccionados.forEach((curso, cursoIdx) => {
            const precioBase = PRECIOS.COLONIA_CURSO_BASE;
            const descuentoCurso = cursoIdx === 1 ? DESCUENTOS.COLONIA.SEGUNDO_CURSO : 0;
            const precioConDescuento = this.pricingCalculator.aplicarDescuento(precioBase, descuentoCurso);

            cursosPromises.push(
              tx.coloniaCursoSeleccionado2026.create({
                data: {
                  estudiante_inscripcion_id: estudianteInscripcion.id,
                  course_id: curso.course_id,
                  course_name: curso.course_name,
                  course_area: curso.course_area,
                  instructor: curso.instructor,
                  day_of_week: curso.day_of_week,
                  time_slot: curso.time_slot,
                  precio_base: precioBase,
                  precio_con_descuento: precioConDescuento,
                },
              })
            );
          });
        }
      });

      if (cursosPromises.length > 0) {
        await Promise.all(cursosPromises);
      }

      // 4.5. Crear mundos seleccionados (usando create individual con Promise.all)
      const mundosPromises = [];
      estudiantesCreados.forEach(({ estudianteInscripcion, mundoSeleccionado }) => {
        if (mundoSeleccionado) {
          mundosPromises.push(
            tx.cicloMundoSeleccionado2026.create({
              data: {
                estudiante_inscripcion_id: estudianteInscripcion.id,
                mundo: mundoSeleccionado,
              },
            })
          );
        }
      });

      if (mundosPromises.length > 0) {
        await Promise.all(mundosPromises);
      }

      // 4.6. üî• Crear pago CON preference_id
      const pago = await tx.pagoInscripcion2026.create({
        data: {
          inscripcion_id: inscripcion.id,
          tipo: 'inscripcion',
          monto: inscripcionFee,
          estado: 'pending',
          mercadopago_preference_id: mercadopagoPreferenceId,
        },
      });

      // 4.7. Crear historial
      await tx.historialEstadoInscripcion2026.create({
        data: {
          inscripcion_id: inscripcion.id,
          estado_anterior: 'none',
          estado_nuevo: 'pending',
          razon: 'Inscripci√≥n creada',
          realizado_por: 'system',
        },
      });

      // Retornar todo lo necesario
      return {
        inscripcion,
        tutor,
        estudiantes: estudiantesCreados,
        pago,
        cursosCount: cursosPromises.length,
        mundosCount: mundosPromises.length,
      };

    }, {
      timeout: 30000, // 30 segundos
      isolationLevel: 'ReadCommitted',
    });

  } catch (error) {
    this.logger.error('Transaction failed, all changes rolled back', {
      error: error.message,
      stack: error.stack,
      preferenceId: mercadopagoPreferenceId,
    });

    // La transacci√≥n ya hizo rollback autom√°ticamente
    throw new InternalServerErrorException(
      'Error al crear la inscripci√≥n. No se realizaron cambios en la base de datos.'
    );
  }

  // Log de performance
  const duration = Date.now() - startTime;

  this.logger.log('Transaction completed successfully', {
    durationMs: duration,
    inscripcionId: result.inscripcion.id,
    tutorId: result.tutor.id,
    numEstudiantes: dto.estudiantes.length,
    numCursos: result.cursosCount,
    numMundos: result.mundosCount,
  });

  // 5Ô∏è‚É£ Construir respuesta
  return {
    success: true,
    inscripcionId: result.inscripcion.id,
    tutorId: result.tutor.id,
    estudiantes_creados: result.estudiantes.map(e => ({
      id: e.estudiante.id,
      nombre: e.estudiante.nombre,
      pin: e.pin,
    })),
    pago_info: {
      monto_total: inscripcionFee,
      descuento_aplicado: siblingDiscount,
      mercadopago_preference_id: mercadopagoPreferenceId,
      mercadopago_init_point: mercadopagoInitPoint,
    },
  };
}
