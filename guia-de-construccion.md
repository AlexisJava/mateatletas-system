# Gu√≠a Estrat√©gica de Desarrollo por Fases para Mateatletas (Monorepo Next.js/NestJS)

Mateatletas es una plataforma educativa que se construir√° mediante un enfoque progresivo por fases, utilizando un monorepo modular que integra Next.js (frontend) y NestJS (backend) junto con Prisma y PostgreSQL. El objetivo es lograr una arquitectura impecable, escalable, testeada y documentada, facilitando adem√°s la colaboraci√≥n entre desarrolladores (y agentes de IA) sin interferencias. A continuaci√≥n se detalla la metodolog√≠a dividida en fases, junto con estrategias de testing, reutilizaci√≥n de componentes y documentaci√≥n viva.

## Fase 0: Setup del entorno y estructura del monorepo

**Objetivo t√©cnico:** Establecer los cimientos del proyecto en un monorepo, con una estructura clara que contenga las aplicaciones de frontend y backend, asegurando configuraciones iniciales consistentes. Se busca un esqueleto de proyecto limpio, funcional y listo para escalar.

### Artefactos esperados:

- **Estructura base del monorepo** (p. ej., directorio ra√≠z con package.json y carpetas /apps o similares). Dentro, un proyecto Next.js (ej. `apps/web`) y un proyecto NestJS (ej. `apps/api`), configurados para trabajar en conjunto.
- **Configuraci√≥n de TypeScript unificada** (tsconfig base y espec√≠ficos para front/back) para permitir compartir tipos.
- **Configuraci√≥n de gestor de paquetes monorepo** (por ejemplo Nx o PNPM Workspaces), scripts de build/start para frontend y backend, y posiblemente un Turborepo para orquestar tareas comunes.
- **Archivos de configuraci√≥n b√°sicos:** ESLint y Prettier para mantener estilo de c√≥digo consistente, configuraci√≥n de env (variables de entorno para dev y producci√≥n, incluyendo credenciales de base de datos, etc.).
- **Setup inicial de Prisma:** archivo schema.prisma vac√≠o o con un par de modelos de ejemplo y conexi√≥n a PostgreSQL configurada (cadena de conexi√≥n en .env).
- **Integraci√≥n de control de versiones y CI/CD inicial:** repositorio Git con un pipeline m√≠nimo (por ejemplo, GitHub Actions) que instale dependencias y ejecute un build de prueba de las apps.

### Dependencias:

No aplica (es la fase inicial). Preparar el entorno es previo a cualquier otra fase, sin dependencias m√°s que tener las herramientas (Node.js, pnpm/npm, Nest CLI, etc.) instaladas.

### Herramientas y librer√≠as recomendadas:

- **NestJS CLI** para crear el proyecto backend (`nest new`) y Create Next App (o equivalente) para iniciar el frontend. Esto agiliza la creaci√≥n de la estructura b√°sica.
- **Nx o Turborepo** para manejar el monorepo eficientemente, permitiendo comandos unificados y caching de builds.
- **TypeScript** (configurado en modo estricto) en todo el repositorio, para garantizar tipado consistente de extremo a extremo.
- **ESLint + Prettier** para asegurar calidad de c√≥digo desde el d√≠a 0.
- **Husky + lint-staged** (opcional) para configurar ganchos pre-commit que ejecuten formateo, linters y tests b√°sicos, evitando introducir errores obvios sin frenar el flujo creativo.

### Criterios de validaci√≥n y cierre de fase:

- **Monorepo estructurado:** se puede levantar el servidor NestJS (ejecutando `npm run start:api`) y la app Next.js (`npm run dev:web`) sin errores, cada uno sirviendo "Hello World" por separado.
- Las dependencias comunes funcionan en ambos proyectos (por ejemplo, TypeScript reconoce tipos compartidos, y se puede importar un tipo desde backend a frontend si as√≠ se define).
- El equipo (o agentes de IA) dispone de documentaci√≥n inicial sobre c√≥mo correr el proyecto, c√≥mo est√° organizada la estructura de carpetas y c√≥mo a√±adir nuevos m√≥dulos. Idealmente, un README inicial describe la arquitectura del monorepo y normas de desarrollo.
- **Entorno listo para siguiente fase:** linters pasando y base de datos PostgreSQL accesible (aunque sin datos reales a√∫n). Un commit etiquetado como fase-0-complete cierra esta fase.

## Fase 1: Construcci√≥n de componentes UI at√≥micos

**Objetivo t√©cnico:** Desarrollar la biblioteca de componentes UI at√≥micos reutilizables, junto con hooks utilitarios front-end, que servir√°n de base para construir funcionalidades m√°s complejas. Se trata de implementar el dise√±o at√≥mico desde √°tomos (botones, inputs, tarjetas) hasta mol√©culas y organismos (secciones completas), asegurando consistencia visual y posibilidad de reutilizaci√≥n en todo el frontend.

### Artefactos esperados:

- **Carpeta de componentes** (ej. `apps/web/src/components/`) que contiene componentes at√≥micos: botones, campos de texto, modal, spinner de carga, etc., siguiendo las gu√≠as de estilo de Mateatletas. Cada componente con su archivo .tsx, estilos (usando Tailwind CSS u otro sistema) y propiedades tipadas.
- **Configuraci√≥n de Tailwind CSS** (o styled-components/Chakra UI seg√∫n elecci√≥n, pero Tailwind est√° sugerido) acorde al sistema de dise√±o: incluir en la configuraci√≥n los colores, fuentes y estilos base definidos para Mateatletas. Por ejemplo, clases utilitarias o componentes estilizados con la "sombra chunky" caracter√≠stica de la marca.
- **Implementaci√≥n de un sistema de dise√±o consistente:** por ejemplo, definir tokens de dise√±o (colores, fuentes) y aplicar principios de dise√±o consistente en los componentes. Artefacto: un archivo de temas o configuraci√≥n de Tailwind que refleja estos tokens.
- **Hooks reutilizables en frontend** (ej. carpeta `hooks/`): por ejemplo, `useAuth()` para manejar estado de autenticaci√≥n (inicialmente puede ser un stub), `useForm()` o hooks que encapsulan l√≥gica repetitiva de formularios, etc.
- **Posiblemente integraci√≥n de Storybook** u otro entorno de documentaci√≥n viva de componentes, donde cada componente est√© catalogado con ejemplos. Esto sirve tanto para ver los componentes aislados como para documentarlos de forma interactiva para el equipo.
- **Pruebas unitarias b√°sicas de componentes:** por ejemplo, usar Vitest o Jest con React Testing Library para verificar que cada componente renderiza correctamente con diferentes props. Artefacto: archivos \*.spec.tsx junto a los componentes.
- **Documentaci√≥n t√©cnica inicial:** puede ser un manual de UI o simplemente MDX dentro de Storybook, explicando las propiedades y uso de cada componente. Tambi√©n un listado de convenciones (e.g., "todos los componentes deben recibir una prop className para estilos personalizados", etc.).

### Dependencias:

Requiere el entorno y proyecto Next.js funcionando (de Fase 0). No depende de l√≥gica de backend ni de datos reales a√∫n. La base de dise√±o puede provenir de gu√≠as de UX ya definidas, pero a nivel t√©cnico esta fase se realiza en gran medida de forma independiente al backend.

### Herramientas y librer√≠as recomendadas:

- **Tailwind CSS** para estilos utilitarios consistentes. Facilita aplicar el sistema de dise√±o sin escribir CSS desde cero, y asegura consistencia tipogr√°fica y de spacing.
- **React Testing Library con Vitest/Jest** para testear componentes UI de forma declarativa (buscando texto, roles accesibles, etc.).
- **Storybook:** altamente recomendado para desarrollo asistido de componentes y como documentaci√≥n viva de la UI. Permite que los dise√±adores (o IA especializadas en front) validen componentes en aislamiento.
- **TanStack React Query:** aunque la integraci√≥n real de datos vendr√° despu√©s, se puede instalar desde ya para usar hooks de datos mock en Storybook o prepararse para el fetching declarativo de datos.
- **Zustand** u otro manejador de estado ligero para el cliente, si se prev√© estado global (por ejemplo, un store de sesi√≥n de usuario). En esta fase podr√≠a crearse el esqueleto de ese store (con estado vac√≠o o simulado) para que los componentes que dependan de estado global puedan usarse luego.

### Criterios de validaci√≥n y cierre de fase:

- **Colecci√≥n de componentes at√≥micos lista:** al menos todos los elementos b√°sicos de la interfaz han sido creados y estilados seg√∫n el dise√±o. Por ejemplo, botones con todos sus estados (hover, active), inputs con validaci√≥n visual de error, etc., disponibles.
- **Reutilizaci√≥n verificada:** Los componentes deben demostrar que pueden integrarse entre s√≠ sin conflictos (por ejemplo, un formulario compuesto de botones e inputs funciona correctamente en Storybook). No hay duplicaci√≥n de estilos ‚Äì se utilizan las utilidades de Tailwind o estilos centralizados en lugar de definiciones ad-hoc repetidas.
- **Pruebas de los componentes pasando:** si un componente tiene l√≥gica (ej. un componente de modal que abre/cierra), hay tests que aseguran que esa l√≥gica funciona. Los tests de snapshot o de render b√°sico pasan sin regresiones visuales significativas.
- **Documentaci√≥n de UI publicada o accesible:** los miembros del equipo pueden ver cada componente y saber c√≥mo usarlo. Esta documentaci√≥n viva (p. ej. Storybook) se considera parte del entregable.
- Esta fase se considera completa cuando el design system b√°sico est√° implementado en c√≥digo y hay confianza (mediante review y tests) de que los componentes pueden ser usados para construir pantallas completas en siguientes fases.

## Fase 2: M√≥dulos funcionales (Auth, Clases, Usuarios, Pagos, Gamificaci√≥n)

**Objetivo t√©cnico:** Implementar las piezas funcionales principales de la plataforma, creando m√≥dulos de dominio tanto en el backend como en el frontend para cada segmento clave: Autenticaci√≥n, Gesti√≥n de Usuarios/Clases, Pagos y Gamificaci√≥n. En esta fase se construyen los endpoints b√°sicos en el backend y las p√°ginas o vistas correspondientes en el frontend, estableciendo la arquitectura modular por dominio en todo el sistema. Aunque algunas partes estar√°n inicialmente esquel√©ticas o con datos simulados, la idea es tener la estructura de cada m√≥dulo en funcionamiento. Cada m√≥dulo tendr√° alta cohesi√≥n interna y bajo acoplamiento con los dem√°s.

### Artefactos esperados:

- **Estructura modular en backend:** Dentro del proyecto NestJS, creaci√≥n de m√≥dulos (carpetas en `src/modules`) para cada dominio: `auth`, `usuarios` (o tutores/estudiantes seg√∫n modelo), `clases` (agenda acad√©mica), `pagos` y `gamificacion`. Cada m√≥dulo con sus subcomponentes t√≠picos: controlador (_.controller.ts), servicio (_.service.ts), entidad o modelo (Prisma client se usar√°, pero podr√≠an definirse clases de dominio si aplica) y DTOS para las operaciones principales. Artefacto espec√≠fico: c√≥digo NestJS que refleja estos m√≥dulos, por ejemplo AuthModule, ClasesModule, etc., registrados en AppModule del backend. Esta organizaci√≥n modular asegurar√° un proyecto ordenado y f√°cil de navegar.
- **Modelos de datos y Prisma:** Definici√≥n del esquema en schema.prisma para las entidades principales (usuarios, clases, inscripciones, pagos, logros, etc.), de acuerdo con el modelo de datos planeado. Tras definirlo, ejecutar migraciones para crear las tablas en PostgreSQL. Artefacto: un conjunto de migraciones SQL generadas por Prisma y el cliente TypeScript de Prisma actualizado (que provee tipos para consultas).
- **Servicios de dominio con l√≥gica b√°sica:** Por ejemplo, en AuthService m√©todos para registrar usuarios y hacer login (inicialmente quiz√° devolviendo tokens dummy), en ClasesService m√©todos para listar clases, en PagosService para crear √≥rdenes de pago (inicialmente simuladas), etc. A√∫n sin todas las validaciones complejas, pero cubriendo el flujo "feliz" de cada caso de uso.
- **Endpoints iniciales:** Definir rutas HTTP en los controladores NestJS para cada funcionalidad principal, aunque algunas devuelvan datos simulados por ahora. Por ejemplo: POST /auth/register, POST /auth/login (retornando JWT), GET /api/clases (lista de clases dummy), POST /api/pagos (inicia pago), etc. Esto permite probar la integraci√≥n m√°s adelante.
- **P√°ginas y vistas en frontend para cada m√≥dulo:** En la aplicaci√≥n Next.js, crear las p√°ginas correspondientes (dentro de la estructura de rutas de Next, posiblemente bajo agrupaciones como (auth) para login/registro, dashboards para usuarios, etc.). Por ejemplo: p√°gina de login, p√°gina de registro, pantalla de listado de clases, pantalla de perfil de usuario, pantalla de compra/pago, pantalla de puntos/logros. De momento, estas p√°ginas pueden usar datos falsos o mocks, pero utilizan los componentes de UI de la fase 1. Artefacto: c√≥digo React/Next.js para cada p√°gina, usando los componentes at√≥micos donde corresponda (ej. la p√°gina de login usando componentes `<Input>` y `<Button>` del design system).
- **Stores o contexto de estado inicial:** Por ejemplo, un store global (usando Zustand o contexto de React) para auth donde se guarda el estado del usuario autenticado (token JWT, rol, etc.), con m√©todos para actualizarlo tras login/logout. Igualmente, quiz√°s un contexto para carrito de pago o similar si aplica. Estos estados globales est√°n listos aunque la l√≥gica interna se complete despu√©s.
- **Integraciones b√°sicas con servicios externos simuladas:** Por ejemplo, en el m√≥dulo de Pagos, incluir la estructura para integrar con Mercado Pago (con un service o provider espec√≠fico), aunque inicialmente simule la creaci√≥n de una preferencia de pago. Similar con cualquier otro servicio externo (p.ej. placeholder para integrar API de Jitsi o OpenAI si corresponde, aunque esas integraciones reales podr√≠an postergarse).
- **Pruebas unitarias iniciales en backend:** Crear tests b√°sicos con Jest para servicios cr√≠ticos. Por ejemplo, probar que AuthService.hashPassword() funciona, o que GamificacionService.calcularNivel() retorna el nivel esperado dado ciertos puntos. Estas pruebas sientan la base para profundizar en Fase 4, pero algunas pueden hacerse ya.
- **Scripts y documentaci√≥n:** Actualizar scripts de package.json para facilitar correr la aplicaci√≥n completa (por ej. un solo comando que inicie backend y frontend en paralelo). Documentar en README u otro doc c√≥mo est√° dividido el c√≥digo en m√≥dulos y c√≥mo se agrega uno nuevo (gu√≠a de contribuci√≥n para modularidad).

### Dependencias:

Requiere los componentes UI de Fase 1 (para construir las p√°ginas front). Depende tambi√©n del esquema de base de datos bien definido (posiblemente dise√±ado en esta misma fase tomando insumos del modelo conceptual definido en documentos). La autenticaci√≥n probablemente depende de tener usuarios en la base de datos; es decir, hay una ligera dependencia en que el modelado de datos est√© listo al empezar a codificar. Fase 2 se apoya en lo logrado en Fase 0 (estructura de proyecto) y sienta las bases para integrarse plenamente en Fase 3.

### Herramientas y librer√≠as recomendadas:

- **Prisma ORM con PostgreSQL:** ya elegido, aqu√≠ se aprovecha para generar migraciones y consultas tipadas. Prisma facilita que cualquier cambio en la estructura de datos se refleje en tipos TypeScript compartidos.
- **Passport JWT (NestJS Guards):** Para implementar autenticaci√≥n en NestJS de forma estandarizada. NestJS ofrece guardias JWT y estrategias de Passport listas para usar, lo que agiliza mucho el m√≥dulo Auth. Herramientas: @nestjs/passport, passport-jwt y @nestjs/jwt.
- **Bcrypt** (u otro algoritmo) para hash de contrase√±as en AuthService.
- **class-validator y class-transformer** en los DTOs de NestJS: esto permite definir validaciones de datos de entrada de forma declarativa en los DTOs de cada m√≥dulo (por ejemplo, requiriendo campos obligatorios, formatos de email, etc.). Se empiezan a usar en esta fase para asegurar la forma correcta de los datos en cada endpoint, aunque el manejo de errores y mensajes se afinar√° en la fase siguiente.
- **Axios en el frontend:** establecer un cliente HTTP √∫nico para consumir la API. Configurarlo con interceptores ahora (por ejemplo, para adjuntar el token JWT a cada petici√≥n autom√°ticamente) facilitar√° la integraci√≥n en fase 3.
- **React Query (TanStack Query):** incorporar su uso para las pantallas que en el futuro consuman datos del backend. En esta fase, se pueden preparar hooks como `useQuery(['clases'], ...)` que por ahora devuelven datos ficticios o usan `enabled: false` hasta que la integraci√≥n real est√© lista. As√≠, las p√°ginas ya manejan estados de carga/error de forma consistente.
- **React Hook Form** (opcional): Para formularios de login, registro, pagos, etc., una librer√≠a como React Hook Form o Formik puede facilitar gesti√≥n de estados de formulario y validaci√≥n en el frontend. Su introducci√≥n en esta fase permite que los formularios de Auth y Pagos sean m√°s robustos, sin duplicar l√≥gica de manejo de inputs en cada componente.

### Criterios de validaci√≥n y cierre de fase:

- **Modularidad lograda:** El c√≥digo est√° organizado en m√≥dulos de dominio claramente separados. Por ejemplo, toda la l√≥gica y rutas de autenticaci√≥n est√°n en auth y no mezcladas con otras. Esto sigue los principios de alta cohesi√≥n y bajo acoplamiento: si se necesita tocar algo de pagos, se sabe exactamente qu√© carpeta revisar, sin dependencias circulares entre m√≥dulos.
- **Funcionalidad b√°sica comprobada:** Se puede ejecutar el backend y realizar una serie de operaciones simples exitosamente, aunque no est√©n al 100% integradas. Ejemplos de validaci√≥n: Registrar un nuevo usuario v√≠a API devuelve un resultado esperado (e inserta en la base de datos), obtener la lista de clases devuelve una estructura coherente (aunque sean datos de prueba), invocar un endpoint de pagos inicia un flujo (simulado) sin error. Para cada m√≥dulo principal, una ruta clave funcionando.
- **Frontend navegable (modo simulado):** Levantando la aplicaci√≥n Next.js, el desarrollador puede navegar a la p√°gina de login, a un dashboard de clases, etc., y la UI se muestra correctamente usando componentes reales. Aunque a√∫n no est√© conectada al backend, la aplicaci√≥n permite una navegaci√≥n "de punta a punta" con datos simulados. (Por ejemplo, despu√©s de "loguearse" se muestra el dashboard de estudiante con una lista est√°tica de clases).
- **Sincron√≠a entre front y back en estructura de datos:** Las interfaces o tipos de datos que representan, por ejemplo, un Usuario o una Clase, est√°n acordes en front y back. Idealmente, ya se comienza a compartir definiciones o a reflejar en TypeScript lo definido en los DTOs del backend. A√∫n si los datos son mock, un desarrollador podr√≠a comparar un objeto JSON de Clase devuelto por el back con lo que el front espera y ver consistencia.
- **Cobertura de pruebas incipiente:** Aunque la mayor parte del testing vendr√° despu√©s, se comprueba que los m√≥dulos nuevos incluyen al menos pruebas unitarias b√°sicas en backend. Todos estos tests (y los de componentes de fase 1) siguen pasando.
- Con esto, la plataforma tiene esqueleto completo: todas las piezas principales est√°n identificadas y creadas, listos para ser conectados entre s√≠ en la siguiente fase. Un checkpoint con commit y quiz√° una revisi√≥n de arquitectura se realiza antes de proceder.

## Fase 3: Integraci√≥n de API, validaciones y contratos de tipos compartidos

**Objetivo t√©cnico:** Conectar completamente frontend y backend, de modo que los m√≥dulos construidos cobren vida con datos reales y reglas de negocio completas. En esta fase se implementan todas las integraciones de API necesarias: el frontend comienza a consumir los endpoints reales del backend para autenticaci√≥n, datos de clases, pagos, etc. Se refina la l√≥gica de negocio en backend (a√±adiendo validaciones m√°s estrictas, manejos de error completos) y se asegura que los contratos de datos (DTOs y tipos TypeScript) se mantengan sincronizados entre backend y frontend. En esencia, se pasa del "esqueleto" a un sistema cohesionado donde las piezas encajan perfectamente y hablan el mismo idioma.

### Artefactos esperados:

- **Conexi√≥n Front-Back establecida:** El c√≥digo frontend realiza llamadas HTTP reales al backend para las funcionalidades clave. Artefactos: implementaci√≥n de llamadas mediante Axios o fetch en los hooks/p√°ginas del front. Ejemplos: la p√°gina de login utiliza un servicio `authService.login(credentials)` que hace POST /auth/login al NestJS y guarda el JWT; la p√°gina de clases usa `useQuery('clases', ...)` que fetch a /api/clases y muestra datos reales desde la BD.
- **Validaciones robustas de entrada y salida:** En el backend, todos los endpoints ahora usan DTOs con validaciones de class-validator para entradas (lanzando errores 400 claros si algo es inv√°lido). En el frontend, se integran validaciones de formularios para proporcionar feedback inmediato al usuario (por ejemplo, usar Yup/Zod con React Hook Form para validar campos antes de enviar). Artefacto: mensajes de error claros en ambos lados y manejo de esos errores (p.ej., mostrar "email ya registrado" en el UI si la API devuelve un error correspondiente).
- **Contratos de tipos unificados:** Se establece una fuente √∫nica de verdad para los tipos de datos compartidos entre front y back. Artefactos posibles:
  - Un paquete o m√≥dulo @mateatletas/shared-types dentro del monorepo que exporta interfaces/Tipos TypeScript para las entidades y DTOs (por ejemplo, User, Class, EnrollmentDTO, etc.), de modo que el backend las implementa y el frontend las reutiliza.
  - Alternativamente, generar autom√°ticamente los tipos TS a partir del esquema de la API (usando Swagger/OpenAPI generado por NestJS y una herramienta como openapi-typescript).
  - En cualquier caso, el resultado es que si se a√±ade o cambia un campo en un DTO backend, el front lo reconoce inmediatamente en compilaci√≥n. Por ejemplo, si backend espera `clase_id: number`, el frontend no podr√° compilar si env√≠a un string. Esta sincronizaci√≥n elimina una categor√≠a entera de bugs antes de que ocurran en producci√≥n.
- **API completa seg√∫n requerimientos:** Todos los endpoints necesarios para las funcionalidades definidas est√°n implementados en NestJS y funcionando correctamente. Por ejemplo: registro/login, CRUD de clases (listar clases disponibles, inscribir a estudiante a una clase), operaciones de pagos (crear pago, webhook de confirmaci√≥n si aplica), asignaci√≥n de puntos/logros de gamificaci√≥n, etc. Artefacto: Colecci√≥n de API (por ej. colecci√≥n Postman o Swagger UI) que documenta cada endpoint, sus par√°metros y respuestas. La API deber√≠a reflejar el API v1.0 planeado.
- **Manejo de estados y sincronizaci√≥n:** En frontend, se afinan los stores y estados para reflejar datos reales. Ej.: el Zustand store de autenticaci√≥n ahora guarda el token real y datos del usuario tras login, y provee m√©todos para logout (limpiando estado). Otro ejemplo: despu√©s de que un tutor inscribe a un estudiante en una clase (acci√≥n en frontend que llama al backend), el estado global o cache de React Query se actualiza para reflejar que esa clase tiene un cupo ocupado adicional, etc. Se implementan mecanismos de sincronizaci√≥n de datos (invalidar caches tras mutaciones, etc.) para mantener coherencia entre cliente y servidor.
- **Seguridad end-to-end:** Aplicar medidas de seguridad en serio: protecci√≥n de rutas en el frontend (redireccionar al login si no autenticado, etc.) y verificaci√≥n de autorizaciones en backend para cada endpoint sensible (usando los Guards y roles). Artefacto: Por ejemplo, un guard en Nest que verifica roles (ya implementado para docentes, tutores, etc.) y en front un componente `<PrivateRoute>` o uso del middleware/route handling de Next.js para restringir el acceso a ciertas p√°ginas si no hay sesi√≥n.
- **Gesti√≥n de errores y edge cases:** Completar la l√≥gica de negocio para casos no felices. Ejemplos: no permitir inscripci√≥n a clase si el cupo est√° lleno (debe dar error desde backend y manejarse en front mostrando mensaje apropiado). Procesar webhooks de pago (si se utilizan) para activar membres√≠as. Asegurarse de que las transacciones de base de datos se manejen correctamente en operaciones complejas (quiz√°s usando transactions de Prisma para operaciones multi-tables).
- **Documentaci√≥n actualizada:** Actualizar o completar la documentaci√≥n t√©cnica para reflejar los contratos finales de la API. Si se usa Swagger (NestJS puede generar documentaci√≥n OpenAPI autom√°ticamente), publicar ese JSON o UI como documentaci√≥n viva de la API. Adem√°s, anotar en la documentaci√≥n decisiones tomadas durante la integraci√≥n (por ejemplo, "decidimos implementar la validaci√≥n X en backend en lugar de front por Y motivo", etc.).

### Dependencias:

Esta fase se basa en todo lo anterior: requiere que los m√≥dulos existan (Fase 2) y que los componentes UI est√©n disponibles (Fase 1). Tambi√©n depende de que el modelo de datos sea s√≥lido. Es interdependiente: a medida que se integran front y back, pueden descubrirse necesidades de ajuste en esquemas o endpoints, lo que a su vez requiere coordinar entre ambos lados. Por ello, la comunicaci√≥n (o en nuestro caso, la sincronizaci√≥n de tipos y buena planificaci√≥n) es crucial.

### Herramientas y librer√≠as recomendadas:

- **Swagger (NestJS)** para documentaci√≥n de API: Decorar los controladores y DTOs con anotaciones Swagger de modo que se genere una especificaci√≥n OpenAPI. Esto sirve para compartir con el equipo y verificar que el contrato es el esperado.
- **OpenAPI Codegen / openapi-typescript:** En caso de optar por generaci√≥n de tipos autom√°tica para frontend, usar estas herramientas en la pipeline para regenerar tipos cuando cambie la API. Alternativamente, explorar tRPC si se quisiera un enfoque de contratos de tipos compartidos de forma autom√°tica (RPC fuertemente tipado), aunque incorporar tRPC a un Nest + Next tradicional no es com√∫n, podr√≠a evaluarse.
- **class-validator** (ya mencionada) y Joi (opcional) para validaci√≥n adicional: NestJS ya usa class-validator para la capa de transporte, pero tambi√©n podr√≠amos usar Joi u otra librer√≠a al nivel de l√≥gica de negocio si se requieren validaciones m√°s complejas en servicio.
- **Sentry** u otra herramienta de monitoreo (opcional esta fase, quiz√° pr√≥xima): Si es posible, integrar ahora monitoreo de errores en frontend y backend para empezar a registrar fallos reales durante las pruebas integrales. No afecta la funcionalidad, pero es buena pr√°ctica de calidad.
- **NestJS e2e testing module:** NestJS permite montar la aplicaci√≥n en modo de prueba. Se puede usar SuperTest junto con Jest para escribir pruebas de integraci√≥n que llamen a varios endpoints reales verificando su interacci√≥n. Esto se puede iniciar en esta fase (por ejemplo, pruebas que simulan un flujo entero: registrar usuario, hacer login, llamar a obtener perfil con el token). Esto complementa la verificaci√≥n manual y ser√° formalizado en Fase 4.

### Criterios de validaci√≥n y cierre de fase:

- **Flujos funcionales end-to-end comprobados:** Al t√©rmino de la fase, un usuario de prueba deber√≠a poder atravesar los escenarios principales en un entorno de staging local: Registrarse, loguearse, navegar su dashboard, inscribirse a una clase, realizar un pago (aunque sea simulado), y obtener puntos o logros. Todo esto usando la UI real conectada al backend real. Cada acci√≥n del usuario en pantalla produce los efectos esperados en la base de datos y en la propia interfaz (ej. tras inscribir a clase, el bot√≥n "Inscribirme" cambia a "Inscripto" y la base de datos refleja la nueva inscripci√≥n).
- **Consistencia de datos garantizada:** Gracias al contrato de tipos compartido, cualquier discrepancia entre front y back se habr√≠a detectado durante el desarrollo. La compilaci√≥n de TypeScript en ambos lados es exitosa y las integraciones no muestran errores de tipo. Si hubo que ajustar campos o nombres, ambos lados se actualizaron al un√≠sono. Esta coherencia es un indicador clave de √©xito en la fase.
- **Validaci√≥n de seguridad y reglas de negocio:** Se prueba que las restricciones funcionan: por ejemplo, un tutor no puede acceder a endpoints reservados a docentes (devuelve 403 Forbidden apropiadamente), no se puede inscribir dos veces al mismo estudiante en la misma clase (la API devuelve error y el front maneja esa situaci√≥n), etc. Estas pruebas pueden hacerse manualmente o con scripts, pero deben pasar antes de cerrar la fase.
- **Cobertura de pruebas de integraci√≥n satisfactoria:** Idealmente, existe un conjunto de pruebas automatizadas que verifican los principales contratos. Por ejemplo, una prueba que haga un POST /auth/login con credenciales v√°lidas y compruebe que devuelve 200 y un token, otra que haga GET /api/clases y espere cierto esquema de datos, etc. Estas pruebas de integraci√≥n demuestran objetivamente que front y back est√°n alineados.
- **Documentaci√≥n de API y gu√≠a de uso actualizada:** Los desarrolladores (o agentes de IA) que tomen el proyecto en este punto deber√≠an contar con un documento de referencia (Swagger UI, Markdown o similar) que liste todos los endpoints, sus par√°metros, y estructuras de respuesta. Adem√°s, la documentaci√≥n interna (README, Notion, etc.) debe reflejar cualquier cambio de decisi√≥n t√©cnica surgido en la integraci√≥n, evitando informaci√≥n obsoleta.
- Con todo lo anterior, el MVP de la plataforma est√° funcional a nivel t√©cnico. Esta fase concluye al lograr un sistema cohesionado y listo para ser rigurosamente testeado y refinado.

## Fase 4: Testing unitario, integraci√≥n y E2E

**Objetivo t√©cnico:** Garantizar la calidad del sistema mediante la implementaci√≥n de una estrategia de testing integral (unitario, integraci√≥n y end-to-end). Aunque se han ido escribiendo pruebas en fases anteriores, en esta etapa se completa la pir√°mide de pruebas, cubriendo todas las capas de la aplicaci√≥n. Se busca detectar y corregir cualquier bug o inconsistencia antes de lanzar el producto, asegurando que tanto el frontend como el backend, y su interacci√≥n, funcionen seg√∫n lo previsto bajo m√∫ltiples escenarios.

### Artefactos esperados:

- **Pruebas unitarias exhaustivas (backend):** Ampliaci√≥n de la bater√≠a de tests unitarios para cada servicio y componente aislado. Artefacto: archivos .spec.ts en Nest que cubren todos los m√©todos importantes de los servicios (por ejemplo, pruebas de que InscripcionesService.crearInscripcion() maneja correctamente casos de √©xito y error). Estas pruebas utilizan mocks para aislar dependencias (mock de Prisma, etc.). El objetivo es que la l√≥gica interna de cada m√≥dulo quede validada en todos los casos de borde posibles.
- **Pruebas unitarias/funcionales (frontend):** Tests con Vitest/Jest y React Testing Library que comprueban la funcionalidad de componentes complejos y hooks. Ejemplos: probar que el formulario de login muestra mensajes de error locales al ingresar datos inv√°lidos, o que el hook `useEnrollClass` llama al endpoint correcto y actualiza estado global apropiadamente. Pueden incluir pruebas con DOM simulado para eventos de usuario en componentes.
- **Pruebas de integraci√≥n (backend):** Utilizando la aplicaci√≥n NestJS levantada en modo de prueba y una base de datos de test separada (Prisma facilita cambiar de DB con variable de entorno), escribir tests que abarcan de controlador a base de datos. Artefacto: por ejemplo, un test para POST /api/inscripciones que: prepara datos en una BD de prueba, llama al endpoint real usando Supertest, y verifica que la respuesta HTTP es correcta y que la base de datos efectivamente registr√≥ la inscripci√≥n. Estos tests validan la integraci√≥n interna del backend (sus distintos m√≥dulos y la BD).
- **Pruebas end-to-end (E2E) del sistema completo:** Scripts de prueba automatizados que simulan acciones de un usuario final en la aplicaci√≥n desplegada o en un entorno de staging. Artefacto: casos de prueba con Playwright o Cypress que abren un navegador, navegan la aplicaci√≥n Next.js como lo har√≠a un usuario y verifican que todo funciona. Ejemplo: un script que abre la p√°gina de login, inicia sesi√≥n con credenciales de prueba, luego navega al listado de clases, reserva una clase, va a la secci√≥n de logros, etc., verificando en cada paso que aparece la UI esperada y, de ser necesario, corroborando en la base de datos que los cambios tuvieron lugar. Estos tests E2E act√∫an como la √∫ltima capa de confianza, probando el sistema como un todo.
- **Informe de cobertura y calidad:** Generaci√≥n de reporte de cobertura de c√≥digo (utilizando Istanbul/nyc integrado con Jest/Vitest). Se espera tener un porcentaje alto de cobertura en unidades cr√≠ticas (idealmente > 80% en backend core y l√≥gica de frontend). M√°s que el n√∫mero, interesa que no queden rutas cr√≠ticas sin probar. Artefacto: reporte de cobertura (HTML, lcov) revisado por el equipo.
- **Integraci√≥n continua de pruebas:** Configuraci√≥n final de la canalizaci√≥n CI para que ejecute toda la suite de tests autom√°ticamente en cada push o PR. Esto incluye paralelizar si es posible (por ejemplo, correr unit tests y e2e en paralelo en distintos jobs). Artefacto: archivos de CI (YAML de GitHub Actions u otro) actualizados para correr `npm test` (y quiz√°s `npm run e2e` por separado) y almacenar resultados/artefactos (logs, screenshots de fallos de Playwright, etc.).
- **Refinamiento basado en pruebas:** Durante esta fase seguramente se refactoriza o corrige c√≥digo para resolver bugs descubiertos. Cada bug corregido idealmente a√±ade un caso de prueba que impida su reaparici√≥n. Un artefacto importante aqu√≠ es el registro de bugs y su resoluci√≥n: documentar brevemente los problemas encontrados y c√≥mo se solucionaron, ya sea en comentarios de commits, en un CHANGELOG o en tickets.

### Dependencias:

Todo el sistema debe estar integrado (Fase 3 completa) para poder probar end-to-end. Tambi√©n depende de tener datos de prueba realistas: ser√° √∫til cargar fixtures o datos semilla en la base de datos de test (por ejemplo, usuarios de prueba, clases de ejemplo) para poder ejecutar pruebas. Esta fase idealmente se ejecuta en paralelo al final de Fase 3 (mientras se integran cosas, se van creando pruebas), pero formalmente depende de la funcionalidad terminada para probarla completamente.

### Herramientas y librer√≠as recomendadas:

- **Jest** (viene por defecto con Nest) para tests unitarios e integraci√≥n en backend. Su entorno ya est√° configurado para TypeScript. Utilizar utilidades de Nest como TestingModule para arrancar m√≥dulos en pruebas de integraci√≥n.
- **Vitest** para tests del frontend, ya que es m√°s r√°pido en recarga que Jest y se integra bien con Vite/Next (si Next.js est√° usando Webpack, tambi√©n se puede usar Jest pero Vitest es una opci√≥n moderna). Incluir React Testing Library para simular interacciones de usuario en componentes.
- **Supertest** para hacer peticiones HTTP simuladas a la API Nest (en tests de integraci√≥n y algunos E2E simples).
- **Playwright o Cypress** para pruebas E2E del frontend+backend. Playwright tiende a ser r√°pido y permite pruebas multi-page y funcionalidades avanzadas; Cypress es tambi√©n popular y con buena DX. Cualquiera sirve; lo importante es automatizar escenarios completos.
- **msw (Mock Service Worker)** (opcional en tests front): Para tests unitarios de componentes que hacen fetch, se puede usar msw para simular las respuestas del backend sin realmente levantarlo. Esto agiliza los tests de front sin perder realismo en las llamadas.
- **Testing Pyramid** concepto gu√≠a: priorizar muchos tests unitarios (r√°pidos), algunos de integraci√≥n, y menos E2E (m√°s lentos), pero cubriendo al menos un flujo por funcionalidad clave. Esto garantiza feedback r√°pido de fallos y cobertura amplia con eficiencia.

### Criterios de validaci√≥n y cierre de fase:

- **Suite de tests pasando al 100%:** No debe haber fallos en ninguna prueba al final de esta fase. Un build de CI debe mostrar verde en todos los jobs de testing.
- **Cobertura de c√≥digo adecuada:** Se alcanza o supera el porcentaje objetivo de cobertura. M√°s importante, se verifica manualmente que las partes cr√≠ticas (autenticaci√≥n, pagos, etc.) est√°n cubiertas por casos de prueba. Si algo no puede ser probado autom√°ticamente (ej. la integraci√≥n con MercadoPago real), se documenta c√≥mo se testea manualmente.
- **Resiliencia demostrada:** Las pruebas E2E ejecutadas en repetidas ocasiones pasan consistentemente, demostrando que el sistema maneja correctamente los estados. Por ejemplo, una prueba que corre 5 veces crear y cancelar pagos no deja la base de datos en estado inconsistente ni produce errores intermitentes. Esto infunde confianza de estabilidad.
- **Correcci√≥n verificada de bugs:** Cualquier bug identificado durante la fase tiene una prueba asociada que confirma su arreglo. La aplicaci√≥n cumple con los requisitos funcionales establecidos, tal como validado por los tests que esencialmente codifican esos requisitos.
- **Go/No-Go listo:** Con todos los tests en verde y documentaci√≥n de pruebas lista, se puede decidir avanzar a optimizaci√≥n y despliegue. Esta fase cierra formalmente cuando el equipo est√° satisfecho de que la calidad es lo suficientemente alta para presentar el producto, al menos internamente. Un informe de prueba final o una reuni√≥n de repaso de calidad puede marcar la aceptaci√≥n de la fase.

## Fase 5: Refactor, documentaci√≥n viva y optimizaci√≥n

**Objetivo t√©cnico:** Realizar una pasada final de refactorizaci√≥n y mejoras de calidad, junto con la consolidaci√≥n de la documentaci√≥n viva del proyecto y optimizaciones de rendimiento u otras antes de lanzar. Aqu√≠ se abordan cualquier deuda t√©cnica menor pendiente, se mejora la legibilidad y mantenibilidad del c√≥digo, y se asegura que toda la documentaci√≥n refleja fielmente el estado actual del sistema. Tambi√©n se optimiza la aplicaci√≥n para producci√≥n (performance, seguridad y despliegue).

### Artefactos esperados:

- **Refactor de c√≥digo cr√≠tico:** Limpieza de secciones de c√≥digo que se identificaron como sub√≥ptimas. Artefacto: commits espec√≠ficos de refactor (sin cambiar funcionalidad) que mejoran aspectos como duplicaci√≥n de c√≥digo, nombres de variables m√°s claros, separaci√≥n de responsabilidades, etc. Por ejemplo, si en fase 3 se escribieron validaciones similares en m√∫ltiples lugares, ahora centralizarlas en un helper √∫nico; o si un componente frontend creci√≥ demasiado, separarlo en subcomponentes.
- **Organizaci√≥n impecable del repositorio:** Verificar y ajustar la estructura de carpetas si es necesario para que siga siendo l√≥gica. A estas alturas, la estructura modular debe permanecer clara. Por ejemplo, puede crearse una carpeta `libs/` compartida si surgieron m√°s utilidades comunes. Todos los m√≥dulos y capas siguen el patr√≥n consistente definido (si alg√∫n m√≥dulo difiere sin raz√≥n, homogenizarlo).
- **Mejoras de rendimiento:** Optimizar consultas y carga donde se pueda. Artefacto: por ejemplo, a√±adir √≠ndices a tablas SQL identificadas como lentas (basado en pruebas de carga ligeras o an√°lisis), ajustar configuraciones de Prisma (pool de conexiones adecuado), implementar lazy loading en frontend para m√≥dulos pesados o dividir el bundle de Next.js para que la carga inicial sea m√°s r√°pida. Correr una pasada de Lighthouse en la aplicaci√≥n web y optimizar puntajes de performance y accesibilidad si es pertinente.
- **Preparaci√≥n para producci√≥n:** Configurar correctamente la aplicaci√≥n para entornos reales. Artefactos: archivos de configuraci√≥n de build/deploy (Dockerfile si se usar√° contenedores, adaptaciones en c√≥digo para variables de entorno de producci√≥n, etc.). Tambi√©n setear medidas de seguridad: HTTPS, variables seguras, pol√≠ticas de CORS adecuadas, rate limiting en API (Nest rate-limiter guard si necesario), etc.
- **Documentaci√≥n "viva" completa:** Actualizaci√≥n final de todos los documentos para que est√©n en sincron√≠a con la versi√≥n actual del sistema. Esto incluye:
  - **Documentaci√≥n de arquitectura:** un documento (o wiki) que recoja las decisiones t√©cnicas tomadas y por qu√©. Idealmente usando un formato de ADR (Architectural Decision Records) para listar decisiones clave (e.g., "Decidimos monorepo Nx por motivo X", "Se eligi√≥ Tailwind por Y", "Se estructura m√≥dulos de dominio seg√∫n Clean Architecture, etc.").
  - **Mapeo de features a commits/tests:** Un registro donde por cada funcionalidad importante se referencia el commit donde se implement√≥ y las pruebas asociadas que la cubren. Esto podr√≠a lograrse mediante mensajes de commit claros (ej. incluyendo ID de historia de usuario) o manteniendo una secci√≥n en la documentaci√≥n que diga "Feature X (commit hash) ‚Äì ver pruebas en archivo ...spec.ts". El objetivo es trazabilidad: poder rastrear la evoluci√≥n de cada requerimiento en el c√≥digo.
  - **Manual de despliegue y operaciones:** Incluir pasos para desplegar la aplicaci√≥n (por ejemplo, c√≥mo ejecutar migraciones de Prisma en producci√≥n, c√≥mo configurar variables de entorno en el servidor, etc.), as√≠ como procedimientos de rollback.
  - **Docs para nuevos desarrolladores:** Un Developer Guide que sirva a futuros colaboradores o agentes de IA para entender r√°pidamente la arquitectura y poner en marcha el proyecto localmente. Mucho de esto ya se tiene de fases previas, pero ahora se consolida y verifica que est√© actualizado.
- **Sincronizaci√≥n de contratos garantizada en adelante:** Implementar mecanismos para mantener la sincron√≠a de contratos de tipos de forma autom√°tica si es posible. Artefacto: por ejemplo, un script en CI que falle si los DTOs de backend han cambiado sin actualizar los tipos compartidos en frontend. O al menos, documentar el proceso para que cada cambio en API conlleve actualizar la librer√≠a de tipos compartidos. La documentaci√≥n debe resaltar este proceso para no romper la coherencia lograda.
- **Optimizaci√≥n continua asistida por IA:** Dado que el desarrollo es asistido por IA, establecer pautas para que los agentes de IA sigan mejorando el c√≥digo sin introducir regresiones. Artefacto: quiz√°s reglas adicionales para herramientas de static analysis o pruebas de calidad (como SonarQube reportes, etc.), de modo que cualquier sugerencia de refactor de una IA pase ciertos checks antes de aplicarse. (Este punto es opcional, orientado a c√≥mo seguir trabajando con IA de forma segura.)

### Dependencias:

Es la etapa final y depende de todo lo anterior completado. No se inicia hasta que los tests de fase 4 est√©n mayormente en verde y el producto funcional est√© feature-complete. Se alimenta tambi√©n de cualquier feedback de rendimiento o revisi√≥n de c√≥digo externa.

### Herramientas y librer√≠as recomendadas:

- **Linting y formato estricto:** Re-ejecutar linters y posiblemente usar herramientas como TSLint/ESLint rulesets m√°s estrictos o Prettier para uniformidad m√°xima.
- **SonarQube/SonarCloud** (opcional): para una pasada de an√°lisis est√°tico de calidad y seguridad del c√≥digo, detectando posibles code smells, duplicaciones, puntos de mejora.
- **Profiler de DB:** utilizar EXPLAIN en consultas SQL complejas via Prisma or logs de Prisma para identificar optimizaciones (a√±adir √≠ndices, etc.).
- **Bundle Analyzer:** para Next.js, usar `next build --analyze` para inspeccionar tama√±o de bundles y realizar code splitting o eliminar dependencias no usadas.
- **Postman/Newman** o integration tests para hacer smoke tests pre-deployment: b√°sicamente volver a correr pruebas de integraci√≥n quiz√° contra un entorno staging preparado con versi√≥n de producci√≥n.
- **Docker/Kubernetes** (si aplica): containerizar la app para desplegarla consistentemente. Esta herramienta depende del stack ops, pero es bueno incluir configuraci√≥n Docker en el repo.
- **Contin√∫a integraci√≥n y despliegue (CI/CD):** Ampliar el pipeline de CI para CD (Continuous Deployment), por ejemplo desplegando en Vercel el front y en un servicio cloud el backend, o construyendo im√°genes Docker y subiendo a alg√∫n registry. Esta configuraci√≥n se documenta para que el sistema de despliegue quede reproducible.

### Criterios de validaci√≥n y cierre de fase:

- **C√≥digo limpio y mantenible:** Revisiones finales de c√≥digo confirman que no hay "malos olores" obvios. Cualquier desarrollador/IA leyendo el c√≥digo deber√≠a entender la estructura f√°cilmente gracias a la consistencia. Tipo de verificaci√≥n: Code review interna o incluso ejecutar una herramienta de an√°lisis y ver que el puntaje de mantenibilidad es bueno.
- **Documentaci√≥n sincronizada con el producto:** Al leer la documentaci√≥n t√©cnica, no hay contradicciones con respecto al comportamiento real del sistema. Cada decisi√≥n importante que uno vea en el c√≥digo aparece explicada en alg√∫n documento. Los contratos de API y tipos en la doc coinciden con los del c√≥digo (gracias al uso de DTOs como documentaci√≥n viva). Tambi√©n, se puede mapear cualquier feature o cambio a su correspondiente registro (commit o nota) de forma sencilla, mostrando trazabilidad completa.
- **Rendimiento aceptable:** Se han realizado pruebas de carga b√°sicas o medido rendimiento del frontend. Por ejemplo, comprobar que una p√°gina con 100 clases carga en pocos segundos, o que el servidor puede manejar, digamos, 50 peticiones concurrentes sin degradaci√≥n notable. No se busca una optimizaci√≥n prematura extrema, pero s√≠ que la app cumpla con requisitos no funcionales m√≠nimos (tiempos de respuesta, etc.). Si se hall√≥ alg√∫n cuello de botella en pruebas, fue mitigado.
- **Preparaci√≥n para escalabilidad:** La arquitectura modular y las pr√°cticas implementadas aseguran que a√±adir un nuevo m√≥dulo o funcionalidad no rompa las existentes. Un criterio aqu√≠ podr√≠a ser hipot√©tico: "¬øqu√© tan f√°cil es ahora incorporar un nuevo m√≥dulo X?" Si la respuesta es "seguimos los patrones ya establecidos, con confianza en tests y tipos compartidos", entonces la fase de refactor logr√≥ solidificar la arquitectura escalable.
- **Checklist de lanzamiento completa:** Antes de dar por concluido, verificar que todos los checklists de calidad se cumplieron: todos los tests OK, docs ok, entorno de producci√≥n configurado, no hay issues de seguridad pendientes, etc. Con eso, se puede declarar que la versi√≥n 1.0 est√° lista.

## Estrategia de Testing Continuo üìä

Una piedra angular del desarrollo progresivo de Mateatletas es la integraci√≥n continua de pruebas en cada fase del ciclo de vida, sin relegarlas al final. Esto garantiza calidad desde el inicio y evita desviaciones. La estrategia sigue el modelo cl√°sico de la Pir√°mide de Pruebas, adaptado a nuestras fases:

- **Fase 0-1 (Setup y UI):** Se configuran frameworks de testing (Jest/Vitest) en el monorepo desde el principio. En la fase 1 ya se escriben pruebas unitarias de componentes UI (por ejemplo, que un bot√≥n renderiza con el texto correcto o que un componente Modal abre y cierra cambiando el estado). Estas pruebas iniciales aseguran que la base de la UI es s√≥lida y previenen regresiones en componentes reutilizables. Se mantienen ligeras para no obstaculizar la creatividad: por ejemplo, snapshots o tests de render simple, ejecutados en segundos cada vez que un componente cambia.

- **Fase 2 (M√≥dulos funcionales):** A medida que se construyen servicios backend y l√≥gica de frontend (ej. hooks), se implementan tests unitarios de l√≥gica. En el backend, por cada m√©todo cr√≠tico de los servicios se crea un test correspondiente usando mocks de dependencias. En el frontend, si se crea, digamos, un hook `useCalculatePoints`, se le escriben tests con distintos escenarios. El enfoque aqu√≠ es desarrollo dirigido por pruebas en lo posible para l√≥gica compleja: por ejemplo, escribir casos de prueba para la asignaci√≥n de puntos de gamificaci√≥n antes de codificarla, asegurando comprender la especificaci√≥n. Estas pruebas unitarias corren r√°pido y dan confianza en cada pieza aislada.

- **Fase 3 (Integraci√≥n):** Al conectar frontend y backend, se incorporan pruebas de integraci√≥n. En backend, tests que cubren desde el controlador hasta la base de datos como un todo (arrancando un m√≥dulo Nest completo con base de datos de prueba). En frontend, se pueden escribir tests de integraci√≥n usando un servidor de pruebas del backend (o simulando con msw) para verificar que un flujo de datos funciona: por ejemplo, montar un componente de lista de clases que en su useEffect hace fetch real a /api/clases (apuntando a una instancia de la API de prueba) y comprobar que tras resolver la promesa los datos aparecen en pantalla. Adem√°s, se puede empezar con tests contractuales: por ejemplo, verificar que la respuesta de cierto endpoint contiene campos que el frontend espera (esto puede hacerse con un schema JSON en tests backend o simplemente mediante los types compartidos). La idea es detectar cualquier desalineaci√≥n de contrato inmediatamente.

- **Fase 4 (Testing intensivo):** Se consolida todo en una suite completa. Las pruebas E2E se ponen en marcha para probar como un usuario real. Estas pruebas end-to-end no es necesario correrlas a cada cambio menor (porque son m√°s lentas), pero s√≠ en cada push importante o al menos diariamente en CI, para asegurarnos de que el sistema completo sigue coherente. Mientras tanto, los tests unitarios e integraci√≥n se ejecutan con cada cambio (incluso en modo watch durante el desarrollo local, para feedback inmediato). La automatizaci√≥n est√° configurada para que al hacer commit o abrir un PR, se ejecuten linters y tests autom√°ticamente, evitando introducir errores en el repositorio principal. Esto no interfiere con el ritmo creativo porque los desarrolladores/IA pueden ejecutar tests localmente cuando lo deseen, y la CI los corre en segundo plano; adem√°s, al haber escrito pruebas desde fases tempranas, ya existen casos que cubren la mayor√≠a de funcionalidades, evitando "p√°nico" de √∫ltimo momento.

- **Fase 5 (Refactor):** Se siguen corriendo toda la bater√≠a de pruebas con cada refactor para asegurarse de no romper nada. Adem√°s, se puede a√±adir tests de rendimiento (no funcionales) si se desea, por ejemplo usando scripts de carga para ver c√≥mo responde la API bajo stress. Cualquier hallazgo puede traducirse en un test o monitor (por ejemplo, si descubrimos un bug al crear 100 usuarios concurrentes, a√±adir un test de esa condici√≥n). La suite de pruebas se convierte en parte de la documentaci√≥n viva del sistema: especifica de forma ejecutable c√≥mo se espera que funcione cada pieza.

### Herramientas de testing en el entorno:

Como se mencion√≥, utilizamos Vitest/Jest para unidades, Jest + Supertest para integraci√≥n API, y Playwright/Cypress para E2E. En particular, Jest ha sido preferido en backend por su integraci√≥n out-of-the-box con NestJS, mientras que en frontend se puede usar Vitest por velocidad. Testing Library aporta buenas pr√°cticas de pruebas en React (enfatizando la experiencia del usuario al buscar elementos por texto/rol en lugar de detalles de implementaci√≥n). Playwright ofrece un runner propio que puede integrarse en la CI para lanzar un navegador headless y simular clics y navegaci√≥n de forma robusta.

### Automatizaci√≥n sin frenar la creatividad:

Es crucial que la automatizaci√≥n trabaje en segundo plano. Para ello:

- Se configura posiblemente Husky para que antes de hacer push, ejecute los tests unitarios r√°pidamente. Si tardan mucho, al menos ejecutar linters y un type-check completo (que ya valida mucho). Los tests completos pueden delegarse a la CI tras el push, manteniendo al desarrollador libre para seguir codeando.
- La CI est√° dise√±ada para proveer feedback r√°pido: por ejemplo, paraleliza la ejecuci√≥n de tests de backend y frontend. Un fallo en tests genera reportes claros (con logs, screenshots si E2E falla, etc.) que facilitan a un agente de IA identificar y corregir el problema.
- No se exige 100% coverage a cada commit intermedio (eso puede interrumpir creatividad); en vez de eso, se aplica un criterio incremental: cada fase tiene requerimientos de testing acordados. Por ejemplo, al terminar Fase 2, se espera cierta cobertura en nuevos m√≥dulos. As√≠, los desarrolladores/IA pueden enfocarse en la l√≥gica primero y luego en los tests, sin posponerlos indefinidamente. Es un balance guiado por la pir√°mide: primero asegurar n√∫cleo con unit tests, luego expandir.

### Validaci√≥n de coherencia entre backend, frontend y datos:

La estrategia de pruebas est√° dise√±ada para verificar constantemente la alineaci√≥n entre las distintas capas:

- El uso de TypeScript compartido ya garantiza en tiempo de compilaci√≥n que muchos desacoples no ocurran (un error de tipo es atrapado antes de ejecutar). Esto es un nivel de verificaci√≥n continuo mientras se desarrolla.
- Las pruebas de integraci√≥n y E2E act√∫an como verificaci√≥n din√°mica: si por ejemplo el frontend espera un campo `precio_base` en la respuesta de productos pero el backend lo llama `base_price`, un test de integraci√≥n/E2E que ejecute ese flujo detectar√° el fallo (o incluso un simple type-check si se comparte la definici√≥n). Aseguramos que todas las definiciones de DTOs (Nest) e interfaces (Next) concuerdan ejecutando tests que serializan/deserializan datos reales.
- Tambi√©n podemos implementar contract testing estilo consumer-driven: crear, por ejemplo, en el frontend un mock de la API que siga la especificaci√≥n esperada y validar contra el real. Pero en nuestro contexto, compartir tipos y hacer integraci√≥n directa en monorepo ya cubre esto de forma m√°s sencilla.
- Finalmente, los tests E2E validan la coherencia completa: desde la entrada de datos por parte del usuario en la interfaz, hasta c√≥mo viaja a la API y se guarda en la base de datos, retornando a la interfaz. Un error de incoherencia (como un campo faltante en la UI o un c√°lculo distinto en front vs back) se manifiestar√° en estos tests de punta a punta. Como ejemplo, en el backend definimos que al inscribir a un estudiante se debe incrementar el contador de cupos ocupados de la clase; un test E2E puede comprobar que tras la inscripci√≥n, la interfaz del tutor muestra el cupo actualizado, confirmando que tanto el backend hizo su trabajo en la BD como que el frontend interpret√≥ y reflej√≥ correctamente ese cambio.

En resumen, el testing continuo significa que cada fase incluye su propio objetivo de pruebas y la calidad se construye incrementalmente. Esto no solo asegura un producto final robusto, sino que permite que m√∫ltiples agentes (humanos o IA) colaboren en paralelo con confianza, ya que los tests act√∫an como guardianes inmediatos de integridad ante cualquier integraci√≥n de c√≥digo.

## Sistema de Reutilizaci√≥n Progresiva ‚ôª

Para mantener la coherencia y velocidad en un proyecto modular extenso, adoptamos un sistema de reutilizaci√≥n progresiva de componentes y l√≥gica, que se va cimentando desde las primeras fases:

- **Componentes UI y hooks primero:** Como se describi√≥ en Fase 1, se construyen todos los componentes at√≥micos de interfaz al inicio, junto con hooks utilitarios, antes de abordar funcionalidades completas. Esto significa que cuando en fases 2 y 3 se desarrollan las p√°ginas y flujos, los desarrolladores (o agentes IA) no necesitan crear botones o modales desde cero ni resolver problemas de estilo repetidamente; simplemente reutilizan las piezas ya probadas. Este enfoque de Dise√±o At√≥mico permite pensar en construir con "lego blocks" predefinidos, logrando velocidad y consistencia visual. Por ejemplo, el mismo componente `<Button>` est√°ndar se usa en todo el sistema para acciones, garantizando comportamiento uniforme (estilos, estados, accesibilidad). Si m√°s adelante se decide cambiar un detalle de estilo, se hace en un solo lugar (el componente) y se refleja en toda la aplicaci√≥n. Lo mismo ocurre con hooks como `useAuth` ‚Äì centraliza la l√≥gica de autenticaci√≥n (login, logout, obtener usuario actual) para que cualquier vista que necesite saber el estado de auth use ese hook en lugar de duplicar l√≥gica. Este hook √∫nico puede ser mejorado con el tiempo (ej. agregando manejo de token refresh) y todas las partes de la app se benefician inmediatamente.

- **Funciones y servicios reutilizables estructurados:** A nivel backend, NestJS por naturaleza fomenta crear servicios que encapsulan la l√≥gica de negocio de cada m√≥dulo. Esos servicios pueden a su vez ser utilizados por otros m√≥dulos si es necesario mediante inyecci√≥n de dependencias, evitando duplicaci√≥n. Por ejemplo, un `UsuariosService` con m√©todo `findUserByEmail` puede ser usado tanto por Auth (para login) como por el m√≥dulo de Usuarios, en lugar de escribir consultas dos veces. En frontend, se organiza c√≥digo com√∫n en helpers o utils y en stores globales cuando tiene sentido. Por ejemplo, si varias p√°ginas necesitan formatear fechas de la misma manera, se crea una utilidad `formatDate()` en un helper com√∫n en lugar de formatear en cada componente de forma diferente. Si tanto front como back necesitan la misma l√≥gica (imaginemos la regla de c√°lculo de nivel de gamificaci√≥n), se podr√≠a colocar en un m√≥dulo compartido (p. ej., una funci√≥n `calcularNivel(puntos)` en `shared/utils.ts`) que el backend y el frontend importan, de modo que ambos lados usan exactamente la misma f√≥rmula. La presencia de un monorepo facilita enormemente este tipo de c√≥digo compartido, eliminando barreras para la reutilizaci√≥n.

- **Evitar duplicaci√≥n de l√≥gica mediante contratos y stores centralizados:** Muchas veces la duplicaci√≥n ocurre entre frontend y backend (ej.: validar formularios en front y luego validar nuevamente en back). Para minimizar esto, definimos claramente responsabilidades: las reglas cr√≠ticas de negocio se implementan en el backend (fuente de verdad), pero gracias al contrato de tipos y DTOs compartidos, podemos derivar algunas reglas al front sin duplicar completamente. Por ejemplo, un DTO de registro de usuario puede tener la regla "el password requiere 8 caracteres"; podemos reutilizar esa regla en el front simplemente teniendo una copia sincronizada de esa definici√≥n (o un esquema de validaci√≥n compartido). Otro ejemplo: la l√≥gica de autorizaci√≥n (¬øpuede este usuario acceder a X?) vive en backend, pero el frontend, conociendo el rol del usuario, puede evitar mostrar opciones no permitidas ‚Äì no es duplicar la regla, sino una optimizaci√≥n de UX; aun as√≠, el guard definitivo es backend. En cuanto a estado compartido, se unifica: en lugar de mantener, digamos, el estado de "usuario logueado" separado en diversas partes, se centraliza en un store (Zustand global, context API). Todas las componentes consumen de ah√≠, evitando estados desincronizados. Si se requiere que varias vistas muestren la misma informaci√≥n (p. ej., el puntaje actual del estudiante), se expone v√≠a ese store global o mediante React Query cache, en vez de cada componente haciendo su propia petici√≥n separada.

- **Construcci√≥n incremental de una librer√≠a compartida:** A medida que el proyecto crece, identificamos utilidades que pueden moverse a un espacio com√∫n. En el monorepo, esto puede significar crear un paquete interno como `libs/commons` o `libs/utils` donde colocar c√≥digo que aplica a varios m√≥dulos. Por ejemplo, tras implementar pagos, quiz√°s descubrimos que la integraci√≥n con la API de MercadoPago tiene funciones que podr√≠an ser √∫tiles en otros contextos; esas funciones se a√≠slan en `libs/payments` para su reutilizaci√≥n. Cada fase ofrece la oportunidad de refactorizar en este sentido: antes de duplicar, abstraer. En fase 5 se termina de consolidar esto, pero la mentalidad est√° desde fase 2: no escribir la misma l√≥gica dos veces. Siempre que surja la tentaci√≥n de copiar/pegar c√≥digo, se eval√∫a moverlo a una funci√≥n com√∫n.

- **Consistencia en la implementaci√≥n:** La reutilizaci√≥n progresiva tambi√©n implica que todos los desarrolladores/agentes sigan patrones consistentes para que el c√≥digo sea coherente. Esto es facilitado por una documentaci√≥n de patrones (p. ej., "As√≠ se crea un nuevo m√≥dulo", "As√≠ se hace un fetch de datos en React Query", etc.). Un beneficio de la modularidad estricta es que cada m√≥dulo sirve de ejemplo para el siguiente. Por ejemplo, si ya hicimos AuthModule y luego alguien trabaja en ClasesModule, puede mirar el primero y replicar la estructura. Igual con componentes: una vez definido un estilo de componente (prop types, estructura de carpetas, testing), todos los nuevos componentes siguen ese molde. Esto significa que con el tiempo el proyecto crece, no en complejidad accidental, sino de forma org√°nica y controlada. Las mismas convenciones se aplican, lo que reduce bugs y facilita que se puedan intercambiar piezas sin romper el sistema.

En resumen, la filosof√≠a es **"Construir una vez, usar en todas partes"**. Primero construir bien las piezas peque√±as (UI, utils, servicios) y luego ensamblarlas para funcionalidades m√°s grandes, en lugar de programar cada pantalla o flujo como algo √∫nico. Esta reutilizaci√≥n progresiva no solo ahorra tiempo, sino que garantiza que la experiencia de usuario y la l√≥gica de negocio sean uniformes en toda la plataforma. Cuando diferentes agentes de IA trabajen en paralelo, esta base compartida reducir√° conflictos: todos estar√°n usando las mismas funciones utilitarias y componentes, as√≠ sus contribuciones ser√°n compatibles entre s√≠ por dise√±o.

## Principios de Documentaci√≥n Viva üìö

Una arquitectura impecable no solo se ve en el c√≥digo, sino tambi√©n en su documentaci√≥n. Por ello, Mateatletas adopta principios de **documentaci√≥n viva**, es decir, documentos que evolucionan junto con el sistema y sirven como fuente confiable de verdad en cada etapa. Estos son los pilares de nuestra estrategia de documentaci√≥n:

- **Registro continuo de decisiones t√©cnicas:** Desde el inicio (fase 0) hasta el final, se mantiene un registro de las decisiones clave. Cada vez que se toma una decisi√≥n de arquitectura, stack o incluso una simplificaci√≥n de implementaci√≥n, se anota en un archivo de decisiones (siguiendo el formato ADR, por ejemplo) o en la wiki del proyecto. El prop√≥sito es que cualquiera (humano o IA) que se una al proyecto m√°s adelante pueda entender por qu√© el sistema es como es. Ejemplos: decisi√≥n de usar NestJS sobre Express, justificaci√≥n de TypeScript por seguridad y auto-documentaci√≥n, elecci√≥n de Prisma vs. otras ORMs, o por qu√© se implement√≥ cierta l√≥gica en backend y no en front. Estas entradas incluyen fecha y contexto, creando una narrativa de la evoluci√≥n t√©cnica. La documentaci√≥n viva aqu√≠ significa que incluso si una decisi√≥n cambia, se actualiza o se agrega una nueva entrada que refleje ese cambio (manteniendo hist√≥rico). No hay documentos muertos: si en fase 2 se dijo "vamos a usar X", pero en fase 4 se cambi√≥ a Y, la documentaci√≥n debe reflejarlo claramente.

- **Mapeo de feature ‚Üí commit ‚Üí test:** Este principio busca trazabilidad total. Cada nueva funcionalidad o historia de usuario implementada debe poder rastrearse en el control de versiones y en la suite de pruebas. En la pr√°ctica, esto se puede implementar de varias formas complementarias:
  - Los mensajes de commit deben ser descriptivos e idealmente referenciar el ID de la funcionalidad o ticket. Por ejemplo: `feat(clases): permitir cancelar clase (resolves #123)`. De este modo, en el historial git se ve claramente qu√© commits introducen qu√© features.
  - Al mismo tiempo, esos commits suelen incluir los tests que cubren la feature. Siguiendo buenas pr√°cticas, en el mismo commit de la feature nueva se agregan o modifican pruebas que la verifican. As√≠, uno puede buscar en el repo y ver "ah, este test corresponde a la funcionalidad X introducida en tal commit".
  - En la documentaci√≥n (p.ej., en la descripci√≥n de la funcionalidad en el README o wiki), se puede incluso listar: "Funcionalidad X fue a√±adida en la versi√≥n 1.2 (commit hash corto), ver pruebas en archivo clases.e2e-spec.ts caso 'deber√≠a cancelar una clase'.". Esto ayuda a que, si alguien est√° leyendo la documentaci√≥n de negocio, pueda saltar al c√≥digo o test relevante directamente.
  - Durante code reviews, se revisa que por cada cambio de l√≥gica importante haya pruebas asociadas y documentaci√≥n actualizada. Esa es la "definici√≥n de done" de cada tarea.

  El resultado es que para cualquier comportamiento del sistema podemos encontrar qu√© c√≥digo lo implementa y c√≥mo se verifica. Esto es invaluable cuando m√∫ltiples agentes desarrollan partes distintas: si algo falla, el traceo de commit->feature->test acelera identificar qui√©n/qu√© lo introdujo.

- **Contratos sincronizados entre backend y frontend:** Ya se ha hecho hincapi√© en compartir DTOs y tipos; esto en s√≠ mismo es documentaci√≥n viva. Los DTOs en NestJS act√∫an como documentaci√≥n ejecutable de la API, definiendo qu√© espera y produce cada endpoint. Aprovechamos eso generando documentaci√≥n API (Swagger) directamente del c√≥digo, evitando discrepancias. En el frontend, las interfaces TypeScript que espejan esos DTOs sirven como documentaci√≥n para los desarrolladores de frontend sobre qu√© datos pueden usar. Para mantener este contrato sincronizado:
  - Se establece un flujo de trabajo donde cualquier cambio en un DTO del backend obliga a considerar su efecto en el front. Esto se puede garantizar mediante revisiones de c√≥digo conjuntas (un PR que cambia un DTO debe pasar por un dev backend y uno frontend, por ejemplo) o mediante herramientas de consistencia (tests o generaci√≥n de tipos).
  - Posiblemente se integra en CI una verificaci√≥n de esquema: por ejemplo, usando la salida OpenAPI del backend y compar√°ndola con un esquema esperado por el front (esto es m√°s complejo, pero opcional).
  - Adem√°s, la documentaci√≥n (en un archivo MD o en Swagger UI) de cada endpoint incluye ejemplos de request/response actualizados autom√°ticamente o manualmente cada vez que algo cambia. Esto act√∫a como contrato legible.

  El principio general es que la √∫nica fuente de verdad del contrato es el c√≥digo mismo, y la documentaci√≥n derivada siempre proviene de √©l. No se mantienen documentos de API escritos a mano separados del c√≥digo, porque tienden a quedar obsoletos; en lugar de eso, se genera del c√≥digo o se comenta en el c√≥digo con claridad.

- **Auto-documentaci√≥n con TypeScript y buenas pr√°cticas:** Se fomenta escribir c√≥digo auto-explicativo, lo cual es otra forma de documentaci√≥n viva. TypeScript, por ejemplo, hace que el c√≥digo sea m√°s auto-documentado al explicitar formas de datos y contratos. Adicionalmente:
  - Se usan JSDoc/TSDoc en funciones y clases p√∫blicas para describir su prop√≥sito, de forma que un desarrollador obtenga esa info al hover en el editor. Estas anotaciones se mantienen al d√≠a cada vez que la funcionalidad cambia.
  - Se podr√≠an generar p√°ginas de documentaci√≥n t√©cnica a partir de estas anotaciones (por ejemplo, con TypeDoc para generar docs de API interna).
  - Se documentan tambi√©n las estructuras de directorios y convenciones en un README para nuevos contribuyentes (por ejemplo, explicar que en `src/modules/` cada m√≥dulo sigue una anatom√≠a est√°ndar). Ese README debe actualizarse si la estructura evoluciona.
  - Finalmente, incorporamos elementos de "living documentation" como Storybook para UI (donde cada componente tiene notas que se actualizan cuando cambian propiedades), o Swagger para API, que se regenera con cada despliegue. Esto significa que la documentaci√≥n siempre refleja la versi√≥n actual de la aplicaci√≥n, no una intenci√≥n pasada.

- **Sincronizaci√≥n con el control de versiones:** Cada fase concluye con una actualizaci√≥n de documentaci√≥n, y preferiblemente, documentaci√≥n y c√≥digo viajan juntos en el repositorio. Por ejemplo, mantener una carpeta `/docs` en el monorepo con los archivos Markdown de arquitectura, decisiones, etc., versionados junto con el c√≥digo. As√≠, si se retrocede a un commit anterior, se puede ver la documentaci√≥n correspondiente a ese momento. Esto es √∫til para entender contextos hist√≥ricos. La documentaci√≥n viva implica que incluso estos archivos se revisan y corrigen en cada PR relevante.

Adherirnos a estos principios asegura trazabilidad y claridad. En un entorno donde m√∫ltiples agentes de IA pueden implementar m√≥dulos simult√°neamente, la documentaci√≥n viva es el punto de alineaci√≥n que previene malentendidos. Cada agente puede consultar la documentaci√≥n para entender el estado actual del sistema y las normas acordadas, y tras hacer sus contribuciones, debe actualizarla para los siguientes.

## Conclusi√≥n

En conclusi√≥n, la metodolog√≠a expuesta proporciona una hoja de ruta estrat√©gica para desarrollar Mateatletas en un entorno modular, asistido por IA, minimizando interferencias. Con fases definidas que se construyen una sobre otra, un enfoque riguroso en testing continuo, la reutilizaci√≥n de componentes/l√≥gica desde el inicio y una documentaci√≥n que evoluciona con el c√≥digo, se logra un proceso de desarrollo robusto y escalable. Cada fase tiene objetivos claros, entregables verificables y criterios de cierre, garantizando trazabilidad. Esto permite que diferentes equipos o agentes trabajen en paralelo de forma armoniosa, siempre alineados con la visi√≥n arquitect√≥nica global y manteniendo la calidad en cada paso del camino. ¬°Al completar estas fases, Mateatletas estar√° listo para brillar con una base s√≥lida tanto en su tecnolog√≠a como en sus pr√°cticas de ingenier√≠a!

---

## Referencias

**Documento de dise√±o T√©cnico del Backend.pdf**  
file://file_00000000c72061f7ab8686c973faa2af

**Stack Tecnol√≥gico y Arquitectura Frontend.pdf**  
file://file_00000000c38461f7b6d52f726989f94b

**How to setup Nest.js & Next.js Mono-Repository? | by Zulfiqar Ali Langah | Medium**  
https://medium.com/@zulfiqar.langah/how-to-setup-nest-js-next-js-mono-repository-8a5d8c3b5849
